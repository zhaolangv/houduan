# 前端集成文档

> **注意**：本文档已根据最新的API规范文档更新，请参考 `后端 API 规范文档.md` 获取完整的API规范。

## 概述

本文档说明前端如何与后端API集成，实现题目图片的OCR识别、去重检查和AI分析。

## 核心流程

```
用户上传图片
  ↓
前端OCR识别（轻量级，如Tesseract.js）
  ↓
判断题目类型（文字题/非文字题）
  ↓
非文字题 → 前端处理或提示用户
文字题 → 提取部分文字（可能不完整）
  ↓
调用后端API，传递：
  - 图片文件
  - OCR原始文本（raw_text）
  - 提取的题干（question_text，可能不准确）
  - 提取的选项（options）
  - 题目类型（question_type: "TEXT"）
  - 是否强制重新分析（force_reanalyze: false）
  ↓
后端返回完整题目数据（题干、选项、答案、解析等）
```

## API接口

### 接口地址

```
POST /api/questions/analyze
```

### 请求格式

**Content-Type**: `multipart/form-data`

### 请求参数

| 参数名 | 类型 | 必需 | 说明 |
|--------|------|------|------|
| `image` | File | ✅ | 题目图片文件（jpg/png/gif/bmp） |
| `raw_text` | String | ❌ | 前端OCR识别的原始文本（所有文字） |
| `question_text` | String | ❌ | 前端提取的题干（可能不完整或不准确） |
| `options` | String/Array | ❌ | 前端提取的选项，JSON字符串格式：`["A. 选项A", "B. 选项B", ...]` |
| `question_type` | String | ❌ | 题目类型，默认 `"TEXT"`（文字题）或 `"GRAPHIC"`（图推题） |
| `force_reanalyze` | Boolean | ❌ | 是否强制重新AI分析，默认 `false` |

### 响应格式

```json
{
    "id": "uuid",
    "screenshot": "图片路径",
    "raw_text": "OCR原始文本",
    "question_text": "完整题干（AI提取）",
    "question_type": "TEXT",
    "options": ["A. 选项A内容", "B. 选项B内容", "C. 选项C内容", "D. 选项D内容"],
    "correct_answer": "B",
    "explanation": "详细解析...",
    "tags": ["行测-数量关系", "比例"],
    "knowledge_points": ["比率与比例", "增长率计算"],
    "answer_versions": [
        {
            "id": "uuid",
            "source_name": "AI",
            "source_type": "AI",
            "answer": "B",
            "explanation": "AI推理：详细解析...",
            "confidence": 0.8,
            "is_user_preferred": false,
            "created_at": "2025-12-05",
            "updated_at": "2025-12-05"
        }
    ],
    "from_cache": true,        // 是否来自缓存
    "is_duplicate": true,       // 是否是重复题
    "saved_to_db": false,       // 是否存入数据库
    "similarity_score": 0.92    // 相似度分数（0-1）
}
```

### 响应字段说明

| 字段名 | 类型 | 说明 |
|--------|------|------|
| `from_cache` | Boolean | `true`表示来自缓存（快速返回，未调用AI），`false`表示调用了AI |
| `is_duplicate` | Boolean | `true`表示是重复题（数据库中已存在），`false`表示新题 |
| `saved_to_db` | Boolean | `true`表示新存入数据库，`false`表示来自已有数据 |
| `similarity_score` | Number | 相似度分数（0-1），仅在`is_duplicate=true`时有效 |

## 前端实现步骤

### 1. 图片上传和OCR识别

#### 1.1 使用Tesseract.js进行OCR

```javascript
// 安装：npm install tesseract.js

import Tesseract from 'tesseract.js';

async function performOCR(imageFile) {
    const { data: { text } } = await Tesseract.recognize(
        imageFile,
        'chi_sim', // 中文简体
        {
            logger: m => console.log(m) // 可选：查看进度
        }
    );
    return text;
}
```

#### 1.2 判断题目类型

```javascript
function detectQuestionType(ocrText) {
    // 简单判断：如果OCR文本很少或包含大量图形相关词汇，可能是图推题
    const textLength = ocrText.trim().length;
    const graphicKeywords = ['图形', '图案', '规律', '序列', '推理'];
    
    const hasGraphicKeywords = graphicKeywords.some(keyword => 
        ocrText.includes(keyword)
    );
    
    // 如果文本很少（<50字符）且没有明显文字题特征，可能是图推题
    if (textLength < 50 && !hasGraphicKeywords) {
        return 'GRAPHIC';
    }
    
    return 'TEXT'; // 默认文字题
}
```

#### 1.3 提取题干和选项

```javascript
function extractQuestionAndOptions(ocrText) {
    const result = {
        raw_text: ocrText,
        question_text: '',
        options: []
    };
    
    // 提取选项（A、B、C、D开头）
    const optionRegex = /^[A-D][\.、。：:\s]+(.+)$/gm;
    const options = [];
    let match;
    
    while ((match = optionRegex.exec(ocrText)) !== null) {
        options.push(match[0].trim()); // 包含"A. "前缀
    }
    
    result.options = options;
    
    // 提取题干（选项之前的所有文字）
    if (options.length > 0) {
        const firstOptionIndex = ocrText.indexOf(options[0]);
        result.question_text = ocrText.substring(0, firstOptionIndex).trim();
    } else {
        result.question_text = ocrText.trim();
    }
    
    return result;
}
```

### 2. 调用后端API

#### 2.1 基础实现

```javascript
async function analyzeQuestion(imageFile, ocrData) {
    const formData = new FormData();
    
    // 必需：图片文件
    formData.append('image', imageFile);
    
    // 可选：前端OCR数据
    if (ocrData.raw_text) {
        formData.append('raw_text', ocrData.raw_text);
    }
    if (ocrData.question_text) {
        formData.append('question_text', ocrData.question_text);
    }
    if (ocrData.options && ocrData.options.length > 0) {
        formData.append('options', JSON.stringify(ocrData.options));
    }
    if (ocrData.question_type) {
        formData.append('question_type', ocrData.question_type);
    }
    
    // 默认不强制重新分析
    formData.append('force_reanalyze', 'false');
    
    try {
        const response = await fetch('/api/questions/analyze', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        return result;
    } catch (error) {
        console.error('分析题目失败:', error);
        throw error;
    }
}
```

#### 2.2 完整示例（React）

```jsx
import React, { useState } from 'react';
import Tesseract from 'tesseract.js';

function QuestionAnalyzer() {
    const [image, setImage] = useState(null);
    const [loading, setLoading] = useState(false);
    const [result, setResult] = useState(null);
    const [error, setError] = useState(null);
    
    const handleImageUpload = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        setImage(file);
        setLoading(true);
        setError(null);
        
        try {
            // 1. 前端OCR识别
            console.log('开始OCR识别...');
            const { data: { text: ocrText } } = await Tesseract.recognize(
                file,
                'chi_sim'
            );
            console.log('OCR识别完成:', ocrText);
            
            // 2. 判断题目类型
            const questionType = detectQuestionType(ocrText);
            console.log('题目类型:', questionType);
            
            // 非文字题，提示用户
            if (questionType === 'GRAPHIC') {
                alert('检测到图推题，请使用专门的图推题功能');
                setLoading(false);
                return;
            }
            
            // 3. 提取题干和选项
            const extracted = extractQuestionAndOptions(ocrText);
            console.log('提取结果:', extracted);
            
            // 4. 调用后端API
            console.log('调用后端API...');
            const apiResult = await analyzeQuestion(file, {
                raw_text: ocrText,
                question_text: extracted.question_text,
                options: extracted.options,
                question_type: questionType
            });
            
            console.log('API返回结果:', apiResult);
            setResult(apiResult);
            
        } catch (err) {
            console.error('处理失败:', err);
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    const handleForceReanalyze = async () => {
        if (!image) return;
        
        setLoading(true);
        try {
            // 强制重新分析
            const formData = new FormData();
            formData.append('image', image);
            formData.append('force_reanalyze', 'true');
            
            const response = await fetch('/api/questions/analyze', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            setResult(result);
        } catch (err) {
            setError(err.message);
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <div>
            <input 
                type="file" 
                accept="image/*" 
                onChange={handleImageUpload}
                disabled={loading}
            />
            
            {loading && <p>处理中...</p>}
            {error && <p style={{color: 'red'}}>错误: {error}</p>}
            
            {result && (
                <div>
                    <h3>分析结果</h3>
                    <p>题目ID: {result.id}</p>
                    <p>题干: {result.question_text}</p>
                    <p>选项: {result.options.join(', ')}</p>
                    <p>正确答案: {result.correct_answer}</p>
                    <p>解析: {result.explanation}</p>
                    
                    <div>
                        <p>来源: {result.from_cache ? '缓存' : 'AI分析'}</p>
                        <p>重复题: {result.is_duplicate ? '是' : '否'}</p>
                        {result.similarity_score && (
                            <p>相似度: {(result.similarity_score * 100).toFixed(1)}%</p>
                        )}
                    </div>
                    
                    <button onClick={handleForceReanalyze}>
                        强制重新分析
                    </button>
                </div>
            )}
        </div>
    );
}

export default QuestionAnalyzer;
```

### 3. 错误处理

```javascript
async function analyzeQuestionWithErrorHandling(imageFile, ocrData) {
    try {
        const result = await analyzeQuestion(imageFile, ocrData);
        return { success: true, data: result };
    } catch (error) {
        // 处理不同类型的错误
        if (error.message.includes('400')) {
            return { 
                success: false, 
                error: '请求参数错误，请检查图片文件' 
            };
        } else if (error.message.includes('500')) {
            return { 
                success: false, 
                error: '服务器错误，请稍后重试' 
            };
        } else {
            return { 
                success: false, 
                error: `处理失败: ${error.message}` 
            };
        }
    }
}
```

## 最佳实践

### 1. OCR优化

- **使用合适的OCR引擎**：
  - 中文：Tesseract.js + `chi_sim`语言包
  - 英文：Tesseract.js + `eng`语言包
  - 混合：可以尝试多个语言包

- **图片预处理**（可选）：
  ```javascript
  // 使用canvas预处理图片（提高OCR准确率）
  function preprocessImage(imageFile) {
      return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              
              // 放大图片（提高OCR准确率）
              canvas.width = img.width * 2;
              canvas.height = img.height * 2;
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              
              // 转换为Blob
              canvas.toBlob(resolve, 'image/jpeg', 0.9);
          };
          img.src = URL.createObjectURL(imageFile);
      });
  }
  ```

### 2. 性能优化

- **OCR并发限制**：避免同时处理多张图片
- **请求去重**：相同图片短时间内不重复请求
- **缓存结果**：前端可以缓存最近的分析结果

```javascript
// 简单的请求去重
const requestCache = new Map();

function getCacheKey(imageFile) {
    return `${imageFile.name}_${imageFile.size}_${imageFile.lastModified}`;
}

async function analyzeQuestionWithCache(imageFile, ocrData) {
    const cacheKey = getCacheKey(imageFile);
    
    // 检查缓存（5分钟内）
    if (requestCache.has(cacheKey)) {
        const cached = requestCache.get(cacheKey);
        if (Date.now() - cached.timestamp < 5 * 60 * 1000) {
            return cached.data;
        }
    }
    
    const result = await analyzeQuestion(imageFile, ocrData);
    
    // 存入缓存
    requestCache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
    });
    
    return result;
}
```

### 3. 用户体验

- **显示处理进度**：
  ```javascript
  Tesseract.recognize(imageFile, 'chi_sim', {
      logger: m => {
          if (m.status === 'recognizing text') {
              const progress = Math.round(m.progress * 100);
              console.log(`OCR进度: ${progress}%`);
              // 更新UI进度条
          }
      }
  });
  ```

- **提供重试机制**：
  ```javascript
  async function analyzeWithRetry(imageFile, ocrData, maxRetries = 3) {
      for (let i = 0; i < maxRetries; i++) {
          try {
              return await analyzeQuestion(imageFile, ocrData);
          } catch (error) {
              if (i === maxRetries - 1) throw error;
              await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));
          }
      }
  }
  ```

## 响应状态说明

### from_cache = true, is_duplicate = true, saved_to_db = false
- **含义**：数据来自缓存/数据库，未调用AI
- **场景**：重复题，后端直接返回已有数据
- **优势**：响应快（< 500ms），节省AI调用
- **字段**：`similarity_score`、`matched_question_id` 会返回

### from_cache = false, is_duplicate = true, saved_to_db = false
- **含义**：调用了AI，但发现是重复题（AI提取后匹配）
- **场景**：AI提取后发现数据库中已有相同题目
- **说明**：数据已存入缓存，下次请求会更快
- **字段**：`similarity_score=1.0`、`matched_question_id` 会返回

### from_cache = false, is_duplicate = true, saved_to_db = true
- **含义**：强制重新分析，更新了已有题目
- **场景**：`force_reanalyze=true` 且找到了重复题
- **说明**：更新了数据库中的题目和答案版本
- **字段**：`similarity_score`、`matched_question_id` 会返回

### from_cache = false, is_duplicate = false, saved_to_db = true
- **含义**：新题目，已调用AI并存入数据库
- **场景**：首次遇到的题目
- **说明**：完整流程，包含AI分析和数据库存储
- **字段**：`similarity_score=null`、`matched_question_id=null`

## 注意事项

1. **图片格式**：支持 jpg、png、gif、bmp，建议使用 jpg 或 png
2. **图片大小**：建议单张图片不超过 5MB
3. **OCR准确性**：前端OCR可能不完整，这是正常的，后端会通过AI补全
4. **强制重新分析**：仅在用户明确要求时使用，会消耗AI资源
5. **错误处理**：始终处理网络错误和API错误

## 示例代码仓库

完整的前端示例代码可以参考：
- React示例：`examples/react-question-analyzer`
- Vue示例：`examples/vue-question-analyzer`
- 原生JS示例：`examples/vanilla-js-question-analyzer`

## 技术支持

如有问题，请联系后端开发团队或查看API文档。

