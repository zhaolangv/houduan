# å‰ç«¯ç‰ˆæœ¬éªŒè¯APIé›†æˆæŒ‡å—

## ğŸ“± Androidä¸“ç”¨ç‰ˆæœ¬éªŒè¯APIè°ƒç”¨

> **æ³¨æ„**ï¼šæœ¬æŒ‡å—ä¸“æ³¨äºAndroidåŸç”Ÿå¼€å‘ã€‚å¦‚æœéœ€è¦React Nativeæˆ–Webç‰ˆæœ¬ï¼Œè¯·å‚è€ƒå…¶ä»–æ–‡æ¡£ã€‚

**å¿«é€Ÿé“¾æ¥**ï¼š
- **Androidå®Œæ•´ç¤ºä¾‹**ï¼šè§ä¸‹æ–¹
- **Androidä¸“ç”¨æŒ‡å—**ï¼š`Androidç‰ˆæœ¬éªŒè¯APIè°ƒç”¨æŒ‡å—.md`ï¼ˆæ›´è¯¦ç»†çš„Androidç¤ºä¾‹ï¼‰

---

## ğŸ”‘ æ ¸å¿ƒæ­¥éª¤

1. **è·å–è®¾å¤‡ID**ï¼ˆç”¨äºç”¨æˆ·ç»Ÿè®¡ï¼‰
2. **è°ƒç”¨ç‰ˆæœ¬éªŒè¯API**ï¼ˆ`/api/version`ï¼‰
3. **å¤„ç†å“åº”**ï¼ˆæ£€æŸ¥æ˜¯å¦éœ€è¦æ›´æ–°ï¼‰
4. **ä¸‹è½½APK**ï¼ˆå¦‚æœéœ€è¦æ›´æ–°ï¼‰

---

## ğŸ“± Android åŸç”Ÿï¼ˆKotlinï¼‰

### å®Œæ•´ç¤ºä¾‹

```kotlin
import android.content.Context
import android.provider.Settings
import android.util.Log
import okhttp3.*
import org.json.JSONObject
import java.io.IOException
import java.util.UUID

class VersionChecker(private val context: Context) {
    private val client = OkHttpClient()
    private val apiBaseUrl = "https://your-api.com" // æ›¿æ¢ä¸ºä½ çš„APIåœ°å€
    
    /**
     * è·å–è®¾å¤‡IDï¼ˆAndroid IDæˆ–UUIDï¼‰
     */
    private fun getDeviceId(): String {
        return try {
            // ä¼˜å…ˆä½¿ç”¨Android IDï¼ˆæ¨èï¼‰
            Settings.Secure.getString(
                context.contentResolver,
                Settings.Secure.ANDROID_ID
            ) ?: run {
                // å¦‚æœAndroid IDä¸å¯ç”¨ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„UUID
                val prefs = context.getSharedPreferences("app_prefs", Context.MODE_PRIVATE)
                var deviceId = prefs.getString("device_id", null)
                if (deviceId == null) {
                    deviceId = UUID.randomUUID().toString()
                    prefs.edit().putString("device_id", deviceId).apply()
                }
                deviceId
            }
        } catch (e: Exception) {
            Log.e("VersionChecker", "è·å–è®¾å¤‡IDå¤±è´¥", e)
            UUID.randomUUID().toString()
        }
    }
    
    /**
     * æ£€æŸ¥ç‰ˆæœ¬å¹¶å¤„ç†æ›´æ–°
     */
    fun checkVersion(
        onUpdateRequired: (latestVersion: String, downloadUrl: String, releaseNotes: String) -> Unit,
        onNoUpdate: () -> Unit = {},
        onError: (error: String) -> Unit = {}
    ) {
        val deviceId = getDeviceId()
        val appVersion = BuildConfig.VERSION_NAME // å¦‚ "1.0.0"
        
        // æ„å»ºè¯·æ±‚URL
        val url = "$apiBaseUrl/api/version?client_version=$appVersion"
        
        // åˆ›å»ºè¯·æ±‚
        val request = Request.Builder()
            .url(url)
            .addHeader("X-Device-ID", deviceId)
            .addHeader("X-App-Version", appVersion)
            .get()
            .build()
        
        // å‘é€è¯·æ±‚
        client.newCall(request).enqueue(object : Callback {
            override fun onResponse(call: Call, response: Response) {
                try {
                    if (!response.isSuccessful) {
                        onError("HTTP ${response.code}: ${response.message}")
                        return
                    }
                    
                    val responseBody = response.body?.string() ?: ""
                    val json = JSONObject(responseBody)
                    
                    if (!json.optBoolean("success", false)) {
                        onError(json.optString("error", "æœªçŸ¥é”™è¯¯"))
                        return
                    }
                    
                    // è§£æç‰ˆæœ¬ä¿¡æ¯
                    val versionInfo = json.getJSONObject("version")
                    val updateInfo = json.getJSONObject("update")
                    
                    val serverVersion = versionInfo.getString("app_version")
                    val requiresUpdate = updateInfo.getBoolean("required")
                    val latestVersion = updateInfo.getString("latest_version")
                    val downloadUrl = updateInfo.getString("download_url")
                    val releaseNotes = updateInfo.optString("release_notes", "")
                    
                    Log.d("VersionChecker", "ç‰ˆæœ¬æ£€æŸ¥å®Œæˆ: å®¢æˆ·ç«¯=$appVersion, æœåŠ¡ç«¯=$serverVersion, éœ€è¦æ›´æ–°=$requiresUpdate")
                    
                    // åœ¨ä¸»çº¿ç¨‹å¤„ç†ç»“æœ
                    (context as? Activity)?.runOnUiThread {
                        if (requiresUpdate) {
                            // éœ€è¦æ›´æ–°
                            onUpdateRequired(latestVersion, downloadUrl, releaseNotes)
                        } else {
                            // ä¸éœ€è¦æ›´æ–°
                            onNoUpdate()
                        }
                    }
                    
                } catch (e: Exception) {
                    Log.e("VersionChecker", "è§£æå“åº”å¤±è´¥", e)
                    onError("è§£æå“åº”å¤±è´¥: ${e.message}")
                }
            }
            
            override fun onFailure(call: Call, e: IOException) {
                Log.e("VersionChecker", "ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥", e)
                onError("ç½‘ç»œé”™è¯¯: ${e.message}")
            }
        })
    }
    
    /**
     * ä¸‹è½½APK
     */
    fun downloadAPK(downloadUrl: String, filename: String = "app-update.apk") {
        val fullUrl = if (downloadUrl.startsWith("http")) {
            downloadUrl
        } else {
            "$apiBaseUrl$downloadUrl"
        }
        
        val request = android.app.DownloadManager.Request(Uri.parse(fullUrl))
        request.setDestinationInExternalPublicDir(
            android.os.Environment.DIRECTORY_DOWNLOADS,
            filename
        )
        request.setNotificationVisibility(
            android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED
        )
        request.setTitle("åº”ç”¨æ›´æ–°")
        request.setDescription("æ­£åœ¨ä¸‹è½½æ–°ç‰ˆæœ¬...")
        
        val downloadManager = context.getSystemService(Context.DOWNLOAD_SERVICE) as android.app.DownloadManager
        downloadManager.enqueue(request)
    }
}

// ä½¿ç”¨ç¤ºä¾‹
class MainActivity : AppCompatActivity() {
    private lateinit var versionChecker: VersionChecker
    
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        
        versionChecker = VersionChecker(this)
        
        // åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥ç‰ˆæœ¬
        checkVersionOnStartup()
    }
    
    private fun checkVersionOnStartup() {
        versionChecker.checkVersion(
            onUpdateRequired = { latestVersion, downloadUrl, releaseNotes ->
                // æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
                showUpdateDialog(latestVersion, downloadUrl, releaseNotes)
            },
            onNoUpdate = {
                Log.d("MainActivity", "åº”ç”¨å·²æ˜¯æœ€æ–°ç‰ˆæœ¬")
            },
            onError = { error ->
                Log.e("MainActivity", "ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥: $error")
                // å¯ä»¥é€‰æ‹©å¿½ç•¥é”™è¯¯ï¼Œä¸å½±å“åº”ç”¨ä½¿ç”¨
            }
        )
    }
    
    private fun showUpdateDialog(version: String, downloadUrl: String, releaseNotes: String) {
        android.app.AlertDialog.Builder(this)
            .setTitle("å‘ç°æ–°ç‰ˆæœ¬ $version")
            .setMessage(releaseNotes.ifEmpty { "æ–°ç‰ˆæœ¬å·²å‘å¸ƒï¼Œå»ºè®®ç«‹å³æ›´æ–°" })
            .setPositiveButton("ç«‹å³æ›´æ–°") { _, _ ->
                // ä¸‹è½½APK
                versionChecker.downloadAPK(downloadUrl, "app-v$version.apk")
                Toast.makeText(this, "å¼€å§‹ä¸‹è½½æ›´æ–°...", Toast.LENGTH_SHORT).show()
            }
            .setNegativeButton("ç¨å", null)
            .setCancelable(false) // å¼ºåˆ¶æ›´æ–°æ—¶å¯ä»¥è®¾ç½®ä¸ºä¸å¯å–æ¶ˆ
            .show()
    }
}
```

### ä¾èµ–é…ç½®

åœ¨ `build.gradle` (Module: app) ä¸­æ·»åŠ ï¼š

```gradle
dependencies {
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'
}
```

---

## ğŸ“± React Native

### å®Œæ•´ç¤ºä¾‹

```javascript
// VersionChecker.js
import DeviceInfo from 'react-native-device-info';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Platform, Alert, Linking } from 'react-native';
import RNFS from 'react-native-fs'; // å¯é€‰ï¼Œç”¨äºæ–‡ä»¶ä¸‹è½½

const API_BASE_URL = 'https://your-api.com'; // æ›¿æ¢ä¸ºä½ çš„APIåœ°å€

class VersionChecker {
  /**
   * è·å–è®¾å¤‡ID
   */
  async getDeviceId() {
    try {
      let deviceId;
      
      if (Platform.OS === 'android') {
        // Android: ä½¿ç”¨Android ID
        deviceId = await DeviceInfo.getAndroidId();
      } else if (Platform.OS === 'ios') {
        // iOS: ä½¿ç”¨IDFVæˆ–UUID
        deviceId = DeviceInfo.getUniqueId();
      }
      
      // å¦‚æœè·å–å¤±è´¥ï¼Œä½¿ç”¨æœ¬åœ°å­˜å‚¨çš„UUID
      if (!deviceId) {
        deviceId = await AsyncStorage.getItem('device_id');
        if (!deviceId) {
          deviceId = `app_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          await AsyncStorage.setItem('device_id', deviceId);
        }
      }
      
      return deviceId;
    } catch (error) {
      console.error('è·å–è®¾å¤‡IDå¤±è´¥:', error);
      // è¿”å›ä¸´æ—¶ID
      return `temp_${Date.now()}`;
    }
  }
  
  /**
   * æ£€æŸ¥ç‰ˆæœ¬
   */
  async checkVersion() {
    try {
      const deviceId = await this.getDeviceId();
      const appVersion = DeviceInfo.getVersion(); // å¦‚ "1.0.0"
      
      const url = `${API_BASE_URL}/api/version?client_version=${appVersion}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'X-Device-ID': deviceId,
          'X-App-Version': appVersion,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥');
      }
      
      const updateInfo = data.update;
      
      return {
        success: true,
        requiresUpdate: updateInfo.required,
        latestVersion: updateInfo.latest_version,
        downloadUrl: updateInfo.download_url,
        releaseNotes: updateInfo.release_notes || '',
        currentVersion: appVersion,
      };
    } catch (error) {
      console.error('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }
  
  /**
   * æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
   */
  showUpdateDialog(version, downloadUrl, releaseNotes, forceUpdate = false) {
    Alert.alert(
      `å‘ç°æ–°ç‰ˆæœ¬ ${version}`,
      releaseNotes || 'æ–°ç‰ˆæœ¬å·²å‘å¸ƒï¼Œå»ºè®®ç«‹å³æ›´æ–°',
      [
        {
          text: 'ç«‹å³æ›´æ–°',
          onPress: () => this.downloadAPK(downloadUrl),
        },
        ...(forceUpdate ? [] : [{ text: 'ç¨å', style: 'cancel' }]),
      ],
      { cancelable: !forceUpdate }
    );
  }
  
  /**
   * ä¸‹è½½APKï¼ˆAndroidï¼‰
   */
  async downloadAPK(downloadUrl) {
    try {
      const fullUrl = downloadUrl.startsWith('http')
        ? downloadUrl
        : `${API_BASE_URL}${downloadUrl}`;
      
      if (Platform.OS === 'android') {
        // Android: ä½¿ç”¨æµè§ˆå™¨ä¸‹è½½æˆ–DownloadManager
        const supported = await Linking.canOpenURL(fullUrl);
        if (supported) {
          await Linking.openURL(fullUrl);
        } else {
          Alert.alert('é”™è¯¯', 'æ— æ³•æ‰“å¼€ä¸‹è½½é“¾æ¥');
        }
      } else {
        Alert.alert('æç¤º', 'iOSåº”ç”¨è¯·é€šè¿‡App Storeæ›´æ–°');
      }
    } catch (error) {
      console.error('ä¸‹è½½APKå¤±è´¥:', error);
      Alert.alert('é”™è¯¯', 'ä¸‹è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// App.js æˆ–ä¸»ç»„ä»¶
import React, { useEffect } from 'react';
import { View, Text } from 'react-native';
import VersionChecker from './VersionChecker';

const versionChecker = new VersionChecker();

function App() {
  useEffect(() => {
    // åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥ç‰ˆæœ¬
    checkVersionOnStartup();
  }, []);
  
  const checkVersionOnStartup = async () => {
    const result = await versionChecker.checkVersion();
    
    if (result.success && result.requiresUpdate) {
      versionChecker.showUpdateDialog(
        result.latestVersion,
        result.downloadUrl,
        result.releaseNotes,
        false // æ˜¯å¦å¼ºåˆ¶æ›´æ–°
      );
    } else if (!result.success) {
      console.warn('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', result.error);
      // å¯ä»¥é€‰æ‹©å¿½ç•¥é”™è¯¯ï¼Œä¸å½±å“åº”ç”¨ä½¿ç”¨
    }
  };
  
  return (
    <View>
      <Text>åº”ç”¨å†…å®¹...</Text>
    </View>
  );
}

export default App;
```

### ä¾èµ–å®‰è£…

```bash
npm install react-native-device-info @react-native-async-storage/async-storage
# æˆ–
yarn add react-native-device-info @react-native-async-storage/async-storage
```

---

## ğŸŒ Web åº”ç”¨ï¼ˆJavaScript/TypeScriptï¼‰

### å®Œæ•´ç¤ºä¾‹

```javascript
// versionChecker.js
class VersionChecker {
  constructor(apiBaseUrl = 'https://your-api.com') {
    this.apiBaseUrl = apiBaseUrl;
  }
  
  /**
   * è·å–æˆ–åˆ›å»ºè®¾å¤‡ID
   */
  getDeviceId() {
    let deviceId = localStorage.getItem('device_id');
    if (!deviceId) {
      // ç”ŸæˆUUID
      deviceId = 'web_' + this.generateUUID();
      localStorage.setItem('device_id', deviceId);
    }
    return deviceId;
  }
  
  /**
   * ç”ŸæˆUUID
   */
  generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  }
  
  /**
   * æ£€æŸ¥ç‰ˆæœ¬
   */
  async checkVersion(appVersion = '1.0.0') {
    try {
      const deviceId = this.getDeviceId();
      const url = `${this.apiBaseUrl}/api/version?client_version=${appVersion}`;
      
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'X-Device-ID': deviceId,
          'X-App-Version': appVersion,
          'Content-Type': 'application/json',
        },
      });
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error || 'ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥');
      }
      
      const updateInfo = data.update;
      
      return {
        success: true,
        requiresUpdate: updateInfo.required,
        latestVersion: updateInfo.latest_version,
        downloadUrl: updateInfo.download_url,
        releaseNotes: updateInfo.release_notes || '',
        currentVersion: appVersion,
        serverVersion: data.version.app_version,
      };
    } catch (error) {
      console.error('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', error);
      return {
        success: false,
        error: error.message,
      };
    }
  }
  
  /**
   * æ˜¾ç¤ºæ›´æ–°æç¤º
   */
  showUpdateDialog(version, downloadUrl, releaseNotes, forceUpdate = false) {
    const message = releaseNotes || `æ–°ç‰ˆæœ¬ ${version} å·²å‘å¸ƒï¼Œå»ºè®®ç«‹å³æ›´æ–°`;
    
    if (confirm(`${message}\n\næ˜¯å¦ç«‹å³æ›´æ–°ï¼Ÿ`)) {
      this.downloadAPK(downloadUrl);
    }
  }
  
  /**
   * ä¸‹è½½APK
   */
  async downloadAPK(downloadUrl) {
    try {
      const fullUrl = downloadUrl.startsWith('http')
        ? downloadUrl
        : `${this.apiBaseUrl}${downloadUrl}`;
      
      // æ–¹æ³•1: ç›´æ¥æ‰“å¼€é“¾æ¥ï¼ˆæµè§ˆå™¨ä¼šä¸‹è½½ï¼‰
      window.location.href = fullUrl;
      
      // æ–¹æ³•2: ä½¿ç”¨fetchä¸‹è½½ï¼ˆæ›´å¯æ§ï¼‰
      // const response = await fetch(fullUrl);
      // const blob = await response.blob();
      // const url = window.URL.createObjectURL(blob);
      // const a = document.createElement('a');
      // a.href = url;
      // a.download = 'app-update.apk';
      // document.body.appendChild(a);
      // a.click();
      // window.URL.revokeObjectURL(url);
      // document.body.removeChild(a);
    } catch (error) {
      console.error('ä¸‹è½½APKå¤±è´¥:', error);
      alert('ä¸‹è½½å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
// app.js æˆ–ä¸»å…¥å£æ–‡ä»¶
const versionChecker = new VersionChecker('https://your-api.com');

// åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥ç‰ˆæœ¬
async function checkVersionOnStartup() {
  const appVersion = '1.0.0'; // ä»é…ç½®æ–‡ä»¶ä¸­è·å–
  
  const result = await versionChecker.checkVersion(appVersion);
  
  if (result.success && result.requiresUpdate) {
    versionChecker.showUpdateDialog(
      result.latestVersion,
      result.downloadUrl,
      result.releaseNotes,
      false // æ˜¯å¦å¼ºåˆ¶æ›´æ–°
    );
  } else if (!result.success) {
    console.warn('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', result.error);
    // å¯ä»¥é€‰æ‹©å¿½ç•¥é”™è¯¯ï¼Œä¸å½±å“åº”ç”¨ä½¿ç”¨
  }
}

// é¡µé¢åŠ è½½å®Œæˆåæ£€æŸ¥
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', checkVersionOnStartup);
} else {
  checkVersionOnStartup();
}
```

### Vue.js ç¤ºä¾‹

```vue
<!-- VersionChecker.vue -->
<template>
  <div v-if="showUpdateDialog" class="update-dialog">
    <div class="dialog-content">
      <h3>å‘ç°æ–°ç‰ˆæœ¬ {{ latestVersion }}</h3>
      <p>{{ releaseNotes }}</p>
      <div class="buttons">
        <button @click="downloadUpdate">ç«‹å³æ›´æ–°</button>
        <button @click="dismissDialog" v-if="!forceUpdate">ç¨å</button>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'VersionChecker',
  data() {
    return {
      showUpdateDialog: false,
      latestVersion: '',
      downloadUrl: '',
      releaseNotes: '',
      forceUpdate: false,
      apiBaseUrl: 'https://your-api.com',
    };
  },
  mounted() {
    this.checkVersion();
  },
  methods: {
    getDeviceId() {
      let deviceId = localStorage.getItem('device_id');
      if (!deviceId) {
        deviceId = 'web_' + this.generateUUID();
        localStorage.setItem('device_id', deviceId);
      }
      return deviceId;
    },
    
    generateUUID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    },
    
    async checkVersion() {
      try {
        const deviceId = this.getDeviceId();
        const appVersion = this.$config.appVersion || '1.0.0';
        const url = `${this.apiBaseUrl}/api/version?client_version=${appVersion}`;
        
        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'X-Device-ID': deviceId,
            'X-App-Version': appVersion,
          },
        });
        
        const data = await response.json();
        
        if (data.success && data.update.required) {
          this.latestVersion = data.update.latest_version;
          this.downloadUrl = data.update.download_url;
          this.releaseNotes = data.update.release_notes || '';
          this.showUpdateDialog = true;
        }
      } catch (error) {
        console.error('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', error);
      }
    },
    
    downloadUpdate() {
      const fullUrl = this.downloadUrl.startsWith('http')
        ? this.downloadUrl
        : `${this.apiBaseUrl}${this.downloadUrl}`;
      window.location.href = fullUrl;
    },
    
    dismissDialog() {
      this.showUpdateDialog = false;
    },
  },
};
</script>
```

### React ç¤ºä¾‹

```jsx
// VersionChecker.jsx
import React, { useEffect, useState } from 'react';

const API_BASE_URL = 'https://your-api.com';

function VersionChecker({ appVersion = '1.0.0' }) {
  const [updateInfo, setUpdateInfo] = useState(null);
  const [showDialog, setShowDialog] = useState(false);
  
  useEffect(() => {
    checkVersion();
  }, []);
  
  const getDeviceId = () => {
    let deviceId = localStorage.getItem('device_id');
    if (!deviceId) {
      deviceId = 'web_' + generateUUID();
      localStorage.setItem('device_id', deviceId);
    }
    return deviceId;
  };
  
  const generateUUID = () => {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === 'x' ? r : (r & 0x3 | 0x8);
      return v.toString(16);
    });
  };
  
  const checkVersion = async () => {
    try {
      const deviceId = getDeviceId();
      const url = `${API_BASE_URL}/api/version?client_version=${appVersion}`;
      
      const response = await fetch(url, {
        headers: {
          'X-Device-ID': deviceId,
          'X-App-Version': appVersion,
        },
      });
      
      const data = await response.json();
      
      if (data.success && data.update.required) {
        setUpdateInfo(data.update);
        setShowDialog(true);
      }
    } catch (error) {
      console.error('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥:', error);
    }
  };
  
  const downloadUpdate = () => {
    if (updateInfo) {
      const fullUrl = updateInfo.download_url.startsWith('http')
        ? updateInfo.download_url
        : `${API_BASE_URL}${updateInfo.download_url}`;
      window.location.href = fullUrl;
    }
  };
  
  if (!showDialog || !updateInfo) {
    return null;
  }
  
  return (
    <div className="update-dialog-overlay">
      <div className="update-dialog">
        <h3>å‘ç°æ–°ç‰ˆæœ¬ {updateInfo.latest_version}</h3>
        <p>{updateInfo.release_notes || 'æ–°ç‰ˆæœ¬å·²å‘å¸ƒï¼Œå»ºè®®ç«‹å³æ›´æ–°'}</p>
        <div className="buttons">
          <button onClick={downloadUpdate}>ç«‹å³æ›´æ–°</button>
          <button onClick={() => setShowDialog(false)}>ç¨å</button>
        </div>
      </div>
    </div>
  );
}

export default VersionChecker;

// åœ¨App.jsä¸­ä½¿ç”¨
import VersionChecker from './VersionChecker';

function App() {
  return (
    <div>
      <VersionChecker appVersion="1.0.0" />
      {/* å…¶ä»–åº”ç”¨å†…å®¹ */}
    </div>
  );
}
```

---

## ğŸ”§ é…ç½®è¯´æ˜

### 1. APIåœ°å€é…ç½®

å°†ç¤ºä¾‹ä¸­çš„ `https://your-api.com` æ›¿æ¢ä¸ºä½ çš„å®é™…APIåœ°å€ï¼š

- **å¼€å‘ç¯å¢ƒ**: `http://localhost:5000`
- **ç”Ÿäº§ç¯å¢ƒ**: `https://your-app.railway.app` æˆ– `https://your-app.onrender.com`

### 2. åº”ç”¨ç‰ˆæœ¬å·

ä»åº”ç”¨é…ç½®ä¸­è·å–ç‰ˆæœ¬å·ï¼š

- **Android**: `BuildConfig.VERSION_NAME`
- **React Native**: `DeviceInfo.getVersion()`
- **Web**: ä»é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡è·å–

### 3. é”™è¯¯å¤„ç†

å»ºè®®çš„é”™è¯¯å¤„ç†ç­–ç•¥ï¼š

```javascript
// ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥ä¸åº”è¯¥é˜»æ­¢åº”ç”¨ä½¿ç”¨
try {
  const result = await checkVersion();
  if (result.requiresUpdate) {
    // æ˜¾ç¤ºæ›´æ–°æç¤º
  }
} catch (error) {
  // é™é»˜å¤±è´¥ï¼Œè®°å½•æ—¥å¿—å³å¯
  console.warn('ç‰ˆæœ¬æ£€æŸ¥å¤±è´¥ï¼Œä½†ä¸å½±å“åº”ç”¨ä½¿ç”¨:', error);
}
```

---

## ğŸ“‹ å®Œæ•´è°ƒç”¨æµç¨‹

```
1. åº”ç”¨å¯åŠ¨
   â†“
2. è·å–è®¾å¤‡IDï¼ˆAndroid ID / UUIDï¼‰
   â†“
3. è°ƒç”¨ /api/version?client_version=1.0.0
   â†“
4. æœåŠ¡å™¨è¿”å›ç‰ˆæœ¬ä¿¡æ¯å’Œæ›´æ–°æç¤º
   â†“
5. å¦‚æœ requiresUpdate=true
   â†“
6. æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
   â†“
7. ç”¨æˆ·ç‚¹å‡»"ç«‹å³æ›´æ–°"
   â†“
8. ä¸‹è½½APKæ–‡ä»¶
```

---

## âœ… æœ€ä½³å®è·µ

1. **åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥**ï¼šåœ¨åº”ç”¨å¯åŠ¨æ—¶è‡ªåŠ¨æ£€æŸ¥ç‰ˆæœ¬
2. **åå°æ£€æŸ¥**ï¼šå¯ä»¥å®šæœŸï¼ˆå¦‚æ¯å¤©ï¼‰æ£€æŸ¥ä¸€æ¬¡
3. **é™é»˜å¤±è´¥**ï¼šç‰ˆæœ¬æ£€æŸ¥å¤±è´¥ä¸åº”è¯¥å½±å“åº”ç”¨ä½¿ç”¨
4. **ç”¨æˆ·é€‰æ‹©**ï¼šé™¤éæ˜¯å¼ºåˆ¶æ›´æ–°ï¼Œå¦åˆ™è®©ç”¨æˆ·é€‰æ‹©æ˜¯å¦æ›´æ–°
5. **ä¸‹è½½è¿›åº¦**ï¼šAndroidå¯ä»¥ä½¿ç”¨DownloadManageræ˜¾ç¤ºä¸‹è½½è¿›åº¦

---

## ğŸ¯ å¿«é€Ÿé›†æˆ

### æœ€ç®€å•çš„é›†æˆæ–¹å¼

**Android**:
```kotlin
// åœ¨Applicationæˆ–MainActivityçš„onCreateä¸­
VersionChecker(context).checkVersion(
    onUpdateRequired = { version, url, notes ->
        // æ˜¾ç¤ºæ›´æ–°å¯¹è¯æ¡†
    }
)
```

**React Native**:
```javascript
// åœ¨App.jsçš„useEffectä¸­
useEffect(() => {
  versionChecker.checkVersion().then(result => {
    if (result.requiresUpdate) {
      // æ˜¾ç¤ºæ›´æ–°æç¤º
    }
  });
}, []);
```

**Web**:
```javascript
// åœ¨é¡µé¢åŠ è½½æ—¶
window.addEventListener('load', () => {
  versionChecker.checkVersion('1.0.0').then(result => {
    if (result.requiresUpdate) {
      // æ˜¾ç¤ºæ›´æ–°æç¤º
    }
  });
});
```

---

**ç°åœ¨ä½ å¯ä»¥è½»æ¾é›†æˆç‰ˆæœ¬éªŒè¯åŠŸèƒ½äº†ï¼** ğŸ‰
